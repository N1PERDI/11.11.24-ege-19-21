def F(x, y, p):
    if x + y >= 77 and p==3: return 1 # Если x+y>=77 и позиция равна 3 (1 Ход Вани), то возвращаем True, что означает победу.
    if x + y < 77 and p==3: return 0 # Если, позиция уже равна 3, но сумарное количество камней меньше, чем должно быть для победы, то возвращаем False (проигрыш).

    return F(x+1, y, p+1) or F(x*2, y, p+1) or F(x, y+1, p+1) or F(x, y*2, p+1) # Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.", то между функциями ставим союз ИЛИ (or)
    # Значение p всегда увеличиваем на 1

for s in range(1, 70):
    if F(s, 7, 1):
        print(s)
# две кучи x - количество камней в одной куче, y - в другой, p-позиция игры. F(s, 7, 1) - начальные значения 




def f(x, m):
    if x >= 68: return m % 2 == 0 # камни в куче
    if m == 0: return 0 # номер хода
    
    steps = [f(x + 1, m - 1), f(x + 4, m - 1), f(x * 5, m - 1)]
    if m % 2 != 0:
        return any (steps)
    else:
        return all(steps)
# В 19 Петя играет не по выигрышной стратегии
# Необходимо поменять all на апу в теле функции
print(*[x for x in range(1, 68) if f(x, 2)])
# Задание Nº20
print(*[x for x in range(1, 68) if f(x, 3) and not f(x, 1)])
# Задание Nº21
print(*[x for x in range (1, 68) if f(x, 4) and not f(x, 2)])




# Этот код моделирует игру с двумя игроками, которые делают ходы, увеличивая число, пока оно не достигнет или превысит 68. 

Функция f(x, m)

• x: Текущее значение числа.
• m: Номер хода (1 - первый ход, 2 - второй ход, 3 - третий ход и т.д.).

Логика функции:

• Базовый случай:
    * Если x >= 68 (число достигло или превысило 68), функция возвращает True (победа), если m четное, и False (проигрыш), если m нечетное. 
• Рекурсивный случай:
    *  В противном случае функция рекурсивно проверяет три возможных хода:
        * Увеличить число на 1 (x + 1).
        * Увеличить число на 4 (x + 4).
        * Умножить число на 5 (x * 5).
    * Если m нечетное, то функция возвращает True, если хотя бы один из возможных ходов приводит к победе (возвращает True в рекурсивном вызове).
    * Если m четное, то функция возвращает True, только если *все* возможные ходы приводят к победе (возвращают True в рекурсивном вызове).

Объяснение кода:

1. Задание 19:

•  print(*[x for x in range(1, 68) if f(x, 2)])
    * Цикл for x in range(1, 68) перебирает все числа от 1 до 67.
    * f(x, 2) проверяет, может ли первый игрок выиграть, если его начальное значение равно x (и он делает второй ход - m = 2).
    * Если функция возвращает True, число x печатается. 
    * Это задание находит все числа x, при которых, если первый игрок делает второй ход (m = 2), он гарантирует себе победу.

2. Задание 20:

• print(*[x for x in range(1, 68) if f(x, 3) and not f(x, 1)])
    * Цикл for x in range(1, 68) перебирает все числа от 1 до 67.
    * f(x, 3) проверяет, может ли первый игрок выиграть, если его начальное значение равно x (и он делает третий ход - m = 3).
    * not f(x, 1) проверяет, может ли первый игрок проиграть, если его начальное значение равно x (и он делает первый ход - m = 1).
    * Если функция возвращает True (то есть, может выиграть на третьем ходу, но проигрывает на первом), число x печатается.
    * Это задание находит все числа x, при которых, если первый игрок делает третий ход (m = 3), он гарантирует себе победу, но проигрывает, если делает первый ход.

3. Задание 21:

• print(*[x for x in range (1, 68) if f(x, 4) and not f(x, 2)])
    * Цикл for x in range(1, 68) перебирает все числа от 1 до 67.
    * f(x, 4) проверяет, может ли первый игрок выиграть, если его начальное значение равно x (и он делает четвертый ход - m = 4).
    * not f(x, 2) проверяет, может ли первый игрок проиграть, если его начальное значение равно x (и он делает второй ход - m = 2).
    * Если функция возвращает True (то есть, может выиграть на четвертом ходу, но проигрывает на втором), число x печатается.
    * Это задание находит все числа x, при которых, если первый игрок делает четвертый ход (m = 4), он гарантирует себе победу, но проигрывает, если делает второй ход.


В целом:

Этот код анализирует игру с заданными правилами и находит числа x, которые дают возможность первому игроку выиграть при определенных условиях (сделанном ходе).
